/******************************************************************//**
 * \file   json.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *********************************************************************/

#ifndef INCLUDE_GUARD_CF7BF358_ECA4_441C_9585_9E7224FE5F70
#define INCLUDE_GUARD_CF7BF358_ECA4_441C_9585_9E7224FE5F70

#include <cassert>
#include <string>

namespace saxy {

struct json_callback {
	void name(string_view name);
	void number(double name);
	void string(string_view name);
	void boolean(bool name);
	void null();
	void start_object();
	void end_object();
	void start_array();
	void end_array();

	void error(saxy::json_error::code ec, std::string::size_type i);
};

struct json_error {
	enum code {
		none,
	};
};

#define SAXY_JSON_STATE(X) goto exit; X: m_state = X;

template <typename Callback>
class json_parser {
	std::string m_field;
	Callback& m_cb;

	enum state {
	} m_state;

public:
	json_parser(Callback& cb)
	: m_cb(cb)
	, m_state{start_of_row} {
	}

	template <typename ForwardIt>
	bool parse(ForwardIt it, ForwardIt end) {
		std::string::size_type index = 0;

		switch(m_state) {
			case start_of_row:      goto start_of_row;
			case start_of_field:    goto start_of_field;
			case in_quoted_field:   goto in_quoted_field;
			case in_unquoted_field: goto in_unquoted_field;
			case in_quote:          goto in_quote;
			case in_new_line:       goto in_new_line;
			case require_line_feed: goto require_line_feed;
			case end_of_field:      goto end_of_field;
			case end_of_row:        goto end_of_row;
			case error:             goto error;
			default: assert("Unknown state in saxy::csv_parser");
		}

		SAXY_CSV_STATE(start_of_row) {
			if(it != end) {
				m_cb.start_row();
				goto start_of_field;
			}
		}

		SAXY_CSV_STATE(start_of_field) {
			while(it != end) {
				++index;
				const char ch = *it++;
				switch(ch) {
					case ',':  goto end_of_field;
					case '"':  goto in_quoted_field;
					case '\r': goto in_new_line;
					default:
						m_field += ch;
						goto in_unquoted_field;
				}
			};
		}

		SAXY_CSV_STATE(in_unquoted_field) {
			while(it != end) {
				++index;
				const char ch = *it++;
				switch(ch) {
					case '"':
						m_cb.error(csv_error::misplaced_double_quotes, index - 1);
						goto error;
					case ',':  goto end_of_field;
					case '\r': goto in_new_line;
					default:
						m_field += ch;
				}
			}
		}

		SAXY_CSV_STATE(in_quoted_field) {
			while(it != end) {
				++index;
				const char ch = *it++;
				switch(ch) {
					case '"': goto in_quote;
					default:
						m_field += ch;
				}
			}
		}

		SAXY_CSV_STATE(in_quote) {
			if(it != end) {
				++index;
				const char ch = *it++;
				switch(ch) {
					case ',':  goto end_of_field;
					case '\r': goto require_line_feed;
					case '"':
						m_field += '"';
						goto in_quoted_field;
					default:
						m_cb.error(csv_error::text_after_closing_quotes, index - 1);
						goto error;
				}
			}
		}

		SAXY_CSV_STATE(in_new_line) {
			if(it != end) {
				++index;
				const char ch = *it++;
				if(ch == '\n') {
					goto end_of_row;
				}

				m_field += '\r';
				if(ch == '\r') {
					goto in_new_line;
				} else {
					m_field += ch;
					goto in_unquoted_field;
				}
			}
		}

		SAXY_CSV_STATE(require_line_feed) {
			if(it != end) {
				++index;
				const char ch = *it++;
				if(ch == '\n') {
					goto end_of_row;
				} else {
					m_cb.error(csv_error::unfinished_crlf, index - 1);
					goto error;
				}
			}
		}

		SAXY_CSV_STATE(end_of_field) {
			m_cb.field(m_field);
			m_field = "";
			goto start_of_field;
		}

		SAXY_CSV_STATE(end_of_row) {
			m_cb.field(m_field);
			m_cb.end_row();
			m_field = "";
			goto start_of_row;
		}

		SAXY_CSV_STATE(error) {
			return false;
		}

		exit:
			return true;
	}
};

#undef SAXY_CSV_STATE

template <typename Callback>
csv_parser<Callback> make_csv_parser(Callback& cb) {
	return csv_parser<Callback>(cb);
}

}

#endif
