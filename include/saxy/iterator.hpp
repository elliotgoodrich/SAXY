/*************************************************************************//**
 * \file   iterator.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ****************************************************************************/

#ifndef INCLUDE_GUARD_517BF7B6_0356_4D02_AE79_24A9C1CE8E5A
#define INCLUDE_GUARD_517BF7B6_0356_4D02_AE79_24A9C1CE8E5A

#if 0
#include "string_view.hpp"

#include <iterator>

namespace saxy {

namespace detail {

template <typename Format, typename StringView>
class iterator_callback {
public:
	typedef typename Format::template event<StringView> Event;
	Event m_event;

	template <typename T>
	always_stop event(typename Format::event e, T t) {
		m_event = Event(e, t);
		return stop;
	}

	always_abort error(typename Format::error_code e) {
		m_event = Event(e);
		return abort;
	}
};

template <typename Format, typename StringView>
struct help {
	typedef typename Format::template event<StringView> type;
};

}

template <typename Format>
class in_place_iterator : public std::iterator<std::input_iterator_tag, typename detail::help<Format, string_view>::type> {
	typedef detail::iterator_callback<Format, string_view> Callback;
	Callback m_cb;
	typename Format::template event_callback<Callback> m_event_cb;
	typename Format::in_place_parser m_parser;

	typedef typename Format::template event<string_view> value_type;
	typedef const value_type& reference;
	typedef const value_type* pointer;

public:
	in_place_iterator()
	: m_cb()
	, m_event_cb(m_cb)
	, m_parser() {
		m_cb.m_event.type = static_cast<typename Format::event>(-1);
	}

	in_place_iterator(string_view input)
	: m_cb()
	, m_event_cb(m_cb)
	, m_parser(input.data(), input.size()) {
		++(*this);
	}

	in_place_iterator<Format>& operator++() {
		m_cb.m_event.type = static_cast<typename Format::event>(-1);
		m_parser.parse(m_event_cb);

		return *this;
	}

	in_place_iterator<Format> operator++(int) {
		in_place_iterator<Format> copy(*this);
		++(*this);
		return copy;
	}

	reference operator*() const {
		return m_cb.m_event;
	}

	pointer operator->() const {
		return &m_cb.m_event;
	}

	void swap(in_place_iterator<Format>& rhs) {
		m_parser.swap(rhs.m_parser);
		m_cb.swap(rhs.m_cb);
	}

	bool operator==(const in_place_iterator<Format>& rhs) {
		return (m_cb.m_event.type == rhs.m_cb.m_event.type) &&
		       m_parser.position() == rhs.m_parser.position();
	}

	bool operator!=(const in_place_iterator<Format>& rhs) {
		return !(*this == rhs);
	}
};

}
#endif

#endif
