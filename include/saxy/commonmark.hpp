/******************************************************************//**
 * \file   commonmark.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *********************************************************************/

#ifndef INCLUDE_GUARD_293DE428_4B0D_4358_B269_11D54FD3CF08
#define INCLUDE_GUARD_293DE428_4B0D_4358_B269_11D54FD3CF08

#include "common.hpp"

#include <cassert>
#include <string>

namespace saxy {

struct commonmark_callback {
	// Blocks
	void horizontal_line();
	void start_header();
	void end_header();

	void start_code_block();
	void end_code_block();

	void start_paragraph();
	void end_paragraph();

	void start_block_quote();
	void end_block_quote();

	void start_ordered_list();
	void end_ordered_list();

	void start_unordered_list();
	void end_unordered_list();

	void text(std::string const&);
};

struct commonmark_error {
	enum code {
		none,
	};
};

class commonmark_parser {
	std::string m_line;

	enum state {
		start_of_line     = 0,                       // 0
		in_indentation    = start_of_line + 1,       // 1
		in_indentation2   = in_indentation + 1,      // 2
		in_indentation3   = in_indentation + 2,      // 3
		in_blockquote     = in_indentation + 3,      // 4
		in_atx_header     = 5,                       // 5
		in_atx_header2    = in_atx_header + 1,       // 6
		in_atx_header3    = in_atx_header + 2,       // 7
		in_atx_header4    = in_atx_header + 3,       // 8
		in_atx_header5    = in_atx_header + 4,       // 9
		in_paragraph      = 10,                      // 10
		in_hr_dash3       = '-',                     // 45
		in_hr_dash2       = in_hr_dash3 - 1,         // 44
		in_hr_dash        = in_hr_dash2 - 1,         // 43
		in_hr_asterix3    = '*',                     // 42
		in_hr_asterix2    = in_hr_asterix3 - 1,      // 41
		in_hr_asterix     = in_hr_asterix2 - 1,      // 40
		in_hr_underscore3 = '_',                     // 95
		in_hr_underscore2 = in_hr_underscore3 - 1,   // 94
		in_hr_underscore  = in_hr_underscore2 - 1,   // 93
		in_block          = 100,                     // 100
		error             = -1,                      // -1
		exit              = -2                       // -2
	};

	enum block {
		blockquote,

	};

	std::vector<block> m_blocks;

	int m_state;

public:
	commonmark_parser()
	: m_state{start_of_line} {
	}

	template <typename Callback, typename ForwardIt>
	bool parse(Callback& cb, ForwardIt it, ForwardIt end) {
		std::string::size_type index = 0;

		int state = m_state;
		switch(state) {
			SAXY_STATE_JUMP_TABLE(start_of_line);
			SAXY_STATE_JUMP_TABLE(in_indentation);
			SAXY_STATE_JUMP_TABLE(in_indentation2);
			SAXY_STATE_JUMP_TABLE(in_indentation3);
			SAXY_STATE_JUMP_TABLE(in_blockquote);
#if 0
			SAXY_STATE_JUMP_TABLE(in_atx_header);
			SAXY_STATE_JUMP_TABLE(in_atx_header2);
			SAXY_STATE_JUMP_TABLE(in_atx_header3);
			SAXY_STATE_JUMP_TABLE(in_atx_header4);
			SAXY_STATE_JUMP_TABLE(in_atx_header5);
			SAXY_STATE_JUMP_TABLE(in_paragraph);
			SAXY_STATE_JUMP_TABLE(in_hr_dash3);
			SAXY_STATE_JUMP_TABLE(in_hr_dash2);
			SAXY_STATE_JUMP_TABLE(in_hr_dash);
			SAXY_STATE_JUMP_TABLE(in_hr_asterix3);
			SAXY_STATE_JUMP_TABLE(in_hr_asterix2);
			SAXY_STATE_JUMP_TABLE(in_hr_asterix);
			SAXY_STATE_JUMP_TABLE(in_hr_underscore3);
			SAXY_STATE_JUMP_TABLE(in_hr_underscore2);
			SAXY_STATE_JUMP_TABLE(in_hr_underscore);
			SAXY_STATE_JUMP_TABLE(in_block);
#endif
			SAXY_STATE_JUMP_TABLE(error);
			SAXY_STATE_JUMP_TABLE(exit);
			default: assert(!"Unknown state in saxy::commonmark_parser");
		}

		start_of_line:
		in_indentation:
		in_indentation2:
		in_indentation3:
			while(it != end) {
				++index;
				const char ch = *it++;
				switch(ch) {
					case ' ': ++state; break;
					case '*': SAXY_CHANGE_STATE(in_hr_asterix);
					case '-': SAXY_CHANGE_STATE(in_hr_dash);
					case '_': SAXY_CHANGE_STATE(in_hr_underscore);
					//case '>': SAXY_CHANGE_STATE(in_blockquote);
					//case '`': SAXY_CHANGE_STATE(in_fenced_block);
					//case '#': SAXY_CHANGE_STATE(in_atx_header);
					default: SAXY_CHANGE_STATE(in_paragraph);
				}

				if(m_state == in_blockquote) {
					goto in_blockquote;
				}
			}

		in_blockquote:
			assert(!"");

		in_hr_asterix:
		in_hr_asterix2:
		in_hr_asterix3:
			while(it != end) {
				++index;
				const char ch = *it++;
				m_line += ch;
				if(ch == '*') {
					++state;
					break;
				} else {
					goto in_paragraph;
				}
			}

#if 0
		in_atx_header:
		in_atx_header2:
		in_atx_header3:
		in_atx_header4:
		in_atx_header5:
			while(it != end) {
				++index;
				const char ch = *it++;
				switch(ch) {
					case '#':
						if(m_state == in_atx_header5) {
							goto in_paragraph;
						}

						++m_state;
						break;
					default: goto in_paragraph;
				}

				if(m_state == in_blockquote) {
					goto in_blockquote;
				}
			}
#endif

		in_paragraph:
			if(it != end) {
				cb.start_paragraph();
				SAXY_CHANGE_STATE(in_text);
			}

		in_text:
			while(it != end) {
				++index;
				const char ch = *it++;
				m_field += ch;
			}

		error:
			return false;

		exit:
			return true;
	}

private:
	
};

#undef SAXY_CSV_STATE

}

#endif
