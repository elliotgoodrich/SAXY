/*************************************************************************//**
 * \file   string_view.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ****************************************************************************/

#ifndef INCLUDE_GUARD_91784151_F862_45C3_9CD9_BEA524AB295E
#define INCLUDE_GUARD_91784151_F862_45C3_9CD9_BEA524AB295E

#include <cassert>
#include <cstring>
#include <iostream>
#include <string>

namespace saxy {

template <typename T>
struct is_const {
	static bool const value = false;
};

template <typename T>
struct is_const<T const> {
	static bool const value = true;
};

template< class T > struct remove_const          { typedef T type; };
template< class T > struct remove_const<const T> { typedef T type; };

template <typename CharT, bool Const = is_const<CharT>::value>
class basic_string_view;

///////////////////////////////////////////////////////////////////////////////
/// basic_string_view<CharT, true> is a non-owning reference to a const string.
///
template <typename ConstCharT>
class basic_string_view<ConstCharT, true> {
public:
	typedef typename remove_const<ConstCharT>::type CharT;
protected:
	CharT const* m_string;
	std::size_t m_length;

public:
	typedef CharT          value_type;
	typedef CharT const*   pointer;
	typedef CharT const*   const_pointer;
	typedef CharT const&   reference;
	typedef CharT const&   const_reference;
	typedef CharT const*   iterator;
	typedef CharT const*   const_iterator;
	typedef std::size_t    size_type;
	typedef std::ptrdiff_t difference_type;

	/// Construct an empty string.
	///
	basic_string_view()
	: m_string(0)
	, m_length(0) {
	}

	/// Construct a string from the null-terminated string \a str.
	///
	basic_string_view(const_pointer str)
	: m_string(str)
	, m_length(std::strlen(str)) {
	}

	/// Construct a string from the string \a str having length \a length. This
	/// string \a str may contain null characters.
	basic_string_view(const_pointer str, size_type length)
	: m_string(str)
	, m_length(length) {
	}

	basic_string_view(std::string const& str)
	: m_string(str.data())
	, m_length(str.size()) {
	}

	basic_string_view(basic_string_view<CharT, true> const& str)
	: m_string(str.m_string)
	, m_length(str.m_length) {
	}

	basic_string_view(basic_string_view<CharT, false> const& str)
	: m_string(str.m_string)
	, m_length(str.m_length) {
	}

	/** Return a const iterator to the beginning of the string.
	 */
	const_iterator begin() const {
		return m_string;
	}

	/** Return a const iterator to the end of the string.
	 */
	const_iterator end() const {
		return m_string + m_length;
	}

	/** Return a const iterator to the beginning of the string.
	 */
	const_iterator cbegin() const {
		return m_string;
	}

	/** Return a const iterator to the end of the string.
	 */
	const_iterator cend() const {
		return m_string + m_length;
	}

	/** Return the size of the string.
	 */
	size_type size() const {
		return m_length;
	}

	/** Return true if and only if the string is empty.
	 */
	bool empty() const {
		return m_length == 0;
	}

	/** Returns a const reference to the character at \a pos.
	 *
	 *  \pre pos < size()
	 */
	const_reference operator[](size_type pos) const {
		assert(pos < m_length);
		return m_string[pos];
	}

	/** Returns a const reference to the first character.
	 *
	 *  \pre !empty()
	 */
	const_reference front() const {
		assert(!empty());
		return *m_string;
	}

	/** Returns a const reference to the last character.
	 *
	 *  \pre !empty()
	 */
	const_reference back() const {
		assert(!empty());
		return m_string[m_length - 1];
	}

	/** Return a const pointer to the start of the string.
	 */
	const_pointer data() const {
		return m_string;
	}

	/** Sets this object to an empty string
	 *
	 *  \post *this == basic_string_view<CharT>()
	 */
	void clear() {
		m_length = 0;
	}

	/** Remove the first \a n characters from the beginning of the string.
	 *
	 * \pre n < size()
	 */
	void remove_prefix(size_type n) {
		assert(n <= m_length);
		m_string += n;
		m_length -= n;
	}

	/** Remove the last \a n characters from the end of the string.
	 *
	 * \pre n < size()
	 */
	void remove_suffix(size_type n) {
		assert(n <= m_length);
		m_length -= n;
	}

	/** Swaps this object with \a other.
	 */
	void swap(basic_string_view<ConstCharT, true>& other) {
		{
			pointer const copy = m_string;
			m_string = other.m_string;
			other.m_string = copy;
		} {
			std::size_t const copy = m_length;
			m_length = other.m_length;
			other.m_length = copy;
		}
	}

	std::string to_string() const {
		return std::string(m_string, m_length);
	}
};

///////////////////////////////////////////////////////////////////////////////
/// basic_string_view<CharT, true> is a non-owning reference to a non-const string.
///
template <typename CharT>
class basic_string_view<CharT, false> : public basic_string_view<CharT const, true> {
public:
	typedef basic_string_view<CharT const, true> base;

	typedef CharT          value_type;
	typedef CharT*         pointer;
	typedef CharT const*   const_pointer;
	typedef CharT&         reference;
	typedef CharT const&   const_reference;
	typedef CharT*         iterator;
	typedef CharT const*   const_iterator;
	typedef std::size_t    size_type;
	typedef std::ptrdiff_t difference_type;

	basic_string_view()
	: base() {
	}

	basic_string_view(pointer str)
	: base(str) {
	}

	basic_string_view(pointer str, size_type length)
	: base(str, length) {
	}

	basic_string_view(std::string& str)
	: base(str) {
	}

	basic_string_view(basic_string_view<const CharT, false> const& str)
	: base(str) {
	}

	/** Return an iterator to the beginning of the string.
	 */
	using base::begin;
	iterator begin() {
		return const_cast<iterator>(base::begin());
	}

	/** Return an iterator to the end of the string.
	 */
	using base::end;
	iterator end() {
		return const_cast<iterator>(base::end());
	}

	/** Returns a reference to the character at \a pos.
	 *
	 *  \pre pos < size()
	 */
	using base::operator[];
	reference operator[](size_type pos) {
		return const_cast<reference>(base::operator[](pos));
	}

	/** Returns a reference to the first character.
	 *
	 *  \pre !empty()
	 */
	using base::front;
	reference front() {
		return const_cast<reference>(base::front());
	}

	/** Returns a reference to the last character.
	 *
	 *  \pre !empty()
	 */
	using base::back;
	reference back() {
		return const_cast<reference>(base::back());
	}

	/** Return a pointer to the start of the string.
	 *
	 *  It is defined to edit a character of this string at position n providing
	 *  0 <= n < size().
	 */
	using base::data;
	pointer data() {
		return const_cast<pointer>(base::data());
	}

	/** Swaps this object with \a other.
	 */
	void swap(basic_string_view<CharT, false>& other) {
		{
			const_pointer copy = this->m_string;
			this->m_string = other.m_string;
			other.m_string = copy;
		} {
			std::size_t const copy = this->m_length;
			this->m_length = other.m_length;
			other.m_length = copy;
		}
	}
};

typedef basic_string_view<char>       string_view;
typedef basic_string_view<char const> string_cview;

template <typename CharT>
bool equal(CharT const* lhs_begin,
           typename basic_string_view<CharT>::size_type lhs_size,
           CharT const* rhs_begin,
           typename basic_string_view<CharT>::size_type rhs_size) {
	if(lhs_size != rhs_size) {
		return false;
	} else if(lhs_begin == rhs_begin) {
		return true;
	}

	for(string_view::size_type i = 0; i < lhs_size; ++i) {
		if(lhs_begin[i] != rhs_begin[i]) {
			return false;
		}
	}

	return true;
}

template <typename CharT>
std::ptrdiff_t compare(CharT const* lhs_begin,
                       typename basic_string_view<CharT>::size_type lhs_size,
                       CharT const* rhs_begin,
                       typename basic_string_view<CharT>::size_type rhs_size) {
	CharT const* lhs_end = lhs_begin + lhs_size;
	CharT const* rhs_end = rhs_begin + rhs_size;
	while(lhs_begin != lhs_end && rhs_begin != rhs_end) {
		if(*lhs_begin < *rhs_begin) {
			return -1;
		} else if(*lhs_begin > *rhs_begin) {
			return 1;
		}

		++lhs_begin;
		++rhs_begin;
	}

	return (lhs_end - lhs_begin) - (rhs_end - rhs_begin);
}

/** Returns true if \a lhs and \a rhs represent strings that compare equal.
 *
 *  \complexity
 *    O(1) if lhs.data() == rhs.data() and lhs.size() == rhs.size()
 *    O(n) otherwise
 */
template <typename CharT1, typename CharT2>
bool operator==(basic_string_view<CharT1> const& lhs,
                basic_string_view<CharT2> const& rhs) {
	return equal(lhs.data(), lhs.size(), rhs.data(), rhs.size());
}

template <typename CharT1, typename Char2>
bool operator==(basic_string_view<CharT1> const& lhs, Char2 const* rhs) {
	return equal(lhs.data(), lhs.size(), rhs, std::strlen(rhs));
}

template <typename CharT1, typename CharT2>
bool operator==(CharT1 const* lhs, basic_string_view<CharT2> const& rhs) {
	return rhs == lhs;
}

template <typename CharT1, typename CharT2>
bool operator==(basic_string_view<CharT1> const& lhs, std::basic_string<CharT2> const& rhs) {
	return equal(lhs.data(), lhs.size(), rhs.data(), rhs.size());
}

template <typename CharT1, typename CharT2>
bool operator==(std::basic_string<CharT1> const& lhs, basic_string_view<CharT2> const& rhs) {
	return rhs == lhs;
}

/** Returns false if \a lhs and \a rhs represent strings that compare equal.
 *
 *  \complexity
 *    O(1) if lhs.data() == rhs.data() and lhs.size() == rhs.size()
 *    O(n) otherwise
 */
template <typename CharT1, typename CharT2>
bool operator!=(basic_string_view<CharT1> const& lhs,
                basic_string_view<CharT2> const& rhs) {
	return !(lhs == rhs);
}

template <typename CharT1, typename Char2>
bool operator!=(basic_string_view<CharT1> const& lhs, Char2 const* rhs) {
	return !(lhs == rhs);
}

template <typename CharT1, typename CharT2>
bool operator!=(CharT1 const* lhs, basic_string_view<CharT2> const& rhs) {
	return !(lhs == rhs);
}

template <typename CharT1, typename CharT2>
bool operator!=(basic_string_view<CharT1> const& lhs, std::basic_string<CharT2> const& rhs) {
	return !(lhs == rhs);
}

template <typename CharT1, typename CharT2>
bool operator!=(std::basic_string<CharT1> const& lhs, basic_string_view<CharT2> const& rhs) {
	return !(lhs == rhs);
}

/** Returns true if \a lhs is lexicographically less than \a rhs
 *
 *  \complexity O(n)
 */
template <typename CharT1, typename CharT2>
bool operator<(basic_string_view<CharT1> const& lhs,
               basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) < 0;
}

template <typename CharT1, typename Char2>
bool operator<(basic_string_view<CharT1> const& lhs, Char2 const* rhs) {
	return compare(lhs.data(), lhs.size(), rhs, std::strlen(rhs)) < 0;
}

template <typename CharT1, typename CharT2>
bool operator<(CharT1 const* lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs, std::strlen(lhs), rhs.data(), rhs.size()) < 0;
}

template <typename CharT1, typename CharT2>
bool operator<(basic_string_view<CharT1> const& lhs, std::basic_string<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) < 0;
}

template <typename CharT1, typename CharT2>
bool operator<(std::basic_string<CharT1> const& lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) < 0;
}

/** Returns true if \a lhs is lexicographically less than or equal to \a rhs
 *
 *  \complexity O(n)
 */
template <typename CharT1, typename CharT2>
bool operator<=(basic_string_view<CharT1> const& lhs,
               basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) <= 0;
}

template <typename CharT1, typename Char2>
bool operator<=(basic_string_view<CharT1> const& lhs, Char2 const* rhs) {
	return compare(lhs.data(), lhs.size(), rhs, std::strlen(rhs)) <= 0;
}

template <typename CharT1, typename CharT2>
bool operator<=(CharT1 const* lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs, std::strlen(lhs), rhs.data(), rhs.size()) <= 0;
}

template <typename CharT1, typename CharT2>
bool operator<=(basic_string_view<CharT1> const& lhs, std::basic_string<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) <= 0;
}

template <typename CharT1, typename CharT2>
bool operator<=(std::basic_string<CharT1> const& lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) <= 0;
}

/** Returns true if \a lhs is lexicographically greater than \a rhs
 *
 *  \complexity O(n)
 */
template <typename CharT1, typename CharT2>
bool operator>(basic_string_view<CharT1> const& lhs,
               basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) > 0;
}

template <typename CharT1, typename Char2>
bool operator>(basic_string_view<CharT1> const& lhs, Char2 const* rhs) {
	return compare(lhs.data(), lhs.size(), rhs, std::strlen(rhs)) > 0;
}

template <typename CharT1, typename CharT2>
bool operator>(CharT1 const* lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs, std::strlen(lhs), rhs.data(), rhs.size()) > 0;
}

template <typename CharT1, typename CharT2>
bool operator>(basic_string_view<CharT1> const& lhs, std::basic_string<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) > 0;
}

template <typename CharT1, typename CharT2>
bool operator>(std::basic_string<CharT1> const& lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) > 0;
}

/** Returns true if \a lhs is lexicographically greater than or equal to \a rhs
 *
 *  \complexity O(n)
 */
template <typename CharT1, typename CharT2>
bool operator>=(basic_string_view<CharT1> const& lhs,
               basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) >= 0;
}

template <typename CharT1, typename Char2>
bool operator>=(basic_string_view<CharT1> const& lhs, Char2 const* rhs) {
	return compare(lhs.data(), lhs.size(), rhs, std::strlen(rhs)) >= 0;
}

template <typename CharT1, typename CharT2>
bool operator>=(CharT1 const* lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs, std::strlen(lhs), rhs.data(), rhs.size()) >= 0;
}

template <typename CharT1, typename CharT2>
bool operator>=(basic_string_view<CharT1> const& lhs, std::basic_string<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) >= 0;
}

template <typename CharT1, typename CharT2>
bool operator>=(std::basic_string<CharT1> const& lhs, basic_string_view<CharT2> const& rhs) {
	return compare(lhs.data(), lhs.size(), rhs.data(), rhs.size()) >= 0;
}

/** Write \a str to the output stream \a out.
 */
template <typename CharT>
std::ostream& operator<<(std::ostream& out,
                         basic_string_view<CharT> const& str) {
	return out.write(str.data(), str.size());
}


}

#endif
