/*************************************************************************//**
 * \file   csv.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ****************************************************************************/

#ifndef INCLUDE_GUARD_EFC18FC4_94A7_4E93_93A6_1D798FF911E9
#define INCLUDE_GUARD_EFC18FC4_94A7_4E93_93A6_1D798FF911E9

#include "common.hpp"
#include "string_view.hpp"

#include <cassert>
#include <cstring>
#ifdef SAXY_CPP11
  #include <functional>
#endif
#include <memory>
#include <vector>

#include <mmintrin.h>
#include <xmmintrin.h>
#include <emmintrin.h>

namespace saxy {

class csv {
	enum state {
		begin,
		start_of_row,
		first_field_of_record,
		fail_on_line_feed,
		start_of_field,
		in_quoted_field,
		in_unquoted_field,
		in_quote,
		in_new_line,
		require_line_feed,
		end_of_field,
		end_of_last_field,
		end_of_row,
		error,
	};

public:
	static char const* name; ///< "CSV"

	/// An enum representing the different types of CSV parsing errors
	///
	enum error_code {
		none = 0,                  ///< No error
		misplaced_double_quotes,   ///< Double quotes appearing in unquoted field
		text_after_closing_quotes, ///< Text found after closing quotes
		unfinished_crlf,           ///< \r found after closing quotes, but the next character is not \n
		unclosed_quote,            ///< Quoted field is unfinished (only occurs with finish())
		no_fields_in_record        ///< A blank line was encountered
	};

	/// An enum representing all of the different events.
	enum event_code {
		start_row_event, ///<
		field_event,     ///< 
		end_row_event,   ///<
		error_event      ///<
	};

	//=========================================================================
	// value
	//=========================================================================
	template <typename StringView>
	class value {
		event_code m_type;
		StringView m_text;
		error_code m_error;

	public:
		/// Create a 'value' object that holds an error code of 'error'.
		///
		value(error_code error);

		value(event_code type, StringView str);

		event_code type() const;

		StringView text() const;

		error_code error() const;
	};

	//=========================================================================
	// event_callback
	//=========================================================================
	/// A class to convert the standard CSV callback methods into ones calling
	/// an event() method, passing an enum with the value of the event.
	template <typename Callback, typename Return = command>
	class event_callback {
		Callback* m_cb;

	public:
		explicit event_callback(Callback& cb)
		: m_cb(&cb) {
		}

		Return start_row() {
			return m_cb->event(start_row_event, string_view());
		}

		template <typename StringView>
		Return field(StringView str) {
			return m_cb->event(field_event, str);
		}

		Return end_row() {
			return m_cb->event(end_row_event, string_view());
		}

		always_abort error(error_code code) {
			return m_cb->error(code);
		}
	};

	//=========================================================================
	// in_place_parser
	//=========================================================================
	/// A class representing an event-based CSV parser that performs a
	/// destructive, or in-place, parse.
	class in_place_parser {
		detail::in_place m_appender;
		char* m_end;
		state m_state;
		char* m_pos;

	public:
		/// Create an in_place_parser that will never generate any events.
		in_place_parser();

		/// Create an in_place_parser that will parse the string starting at \a
		/// start and has a length of \a length.
		///
		/// @pre: \a start must not be null and must point to an array of at
		///       least \a length characters.
		/// @warning: When \a parse is called the string will almost certainly
		///           be modified.
		in_place_parser(char* start, std::size_t length);

		/// 
		char const* position() const;

		char const* end() const {
			return m_end;
		}

		std::ptrdiff_t remaining_bytes() const {
			return end() - position();
		}

		/// Parse at most 'max_parse' characters as CSV and call the callback
		/// 'cb' with the appropriate method each time a parsing event is
		/// generated. The return value of the callback method determines
		/// whether the parsing continues. This method returns true unless
		/// a method returns saxy::abort.
		template <typename Callback>
		bool parse(Callback& cb, std::size_t max_parse = -1);
	};

	//=========================================================================
	// parser
	//=========================================================================
	/// A class representing an event-based CSV parser that performs a
	/// non-destructive, but slower than \a in_place_parser, parse.
	template <template <typename> class Allocator = std::allocator>
	class parser {
		std::vector<char, Allocator<char> > m_field;
		state m_state;

		template <template <typename> class OtherAlloc>
		friend class parser;

	public:
		parser();

		explicit parser(std::size_t initial_capacity);

		parser(std::size_t initial_capacity, const Allocator<char>& alloc);

		std::size_t hash() const;

		template <typename Callback>
		bool finish(Callback& cb);

		template <typename Callback>
		bool parse(Callback& cb, char const* str, char const** out = 0);

		template <typename Callback, typename ForwardIt>
		bool parse(Callback& cb, ForwardIt it, ForwardIt end, ForwardIt* out = 0);

		template <template <typename> class RAllocator>
		bool operator==(parser<RAllocator> const& rhs);

		template <template <typename> class RAllocator>
		bool operator!=(parser<RAllocator> const& rhs);
	};

	template <typename Callback>
	static bool parse(Callback& cb, char* start, std::size_t length, char** out = 0) {
		state s = begin;
		detail::in_place ap(start);
		return parse_impl(ap, cb, s, start, start + length, out)
		    && finish_impl(ap, cb, s);
	}

	template <typename Callback>
	static bool parse(Callback& cb, char* start, char** out = 0) {
		state s = begin;
		detail::in_place ap(start);
		return parse_impl(ap, cb, s, start, detail::cstr_end_iterator(), out)
		    && finish_impl(ap, cb, s);
	}

private:
	template <typename Appender, typename Callback>
	static bool finish_impl(Appender& ap, Callback& cb, state& m_state) {
		switch(m_state) {
			case begin:
				require_abort(cb.error(error_code::no_fields_in_record));
				return false;
			case fail_on_line_feed:
			case in_new_line:
				ap.append('\r');
			case start_of_field:
			case in_unquoted_field:
			case in_quote:
				m_state = end_of_row; // untested line
				SAXY_RUN_CALLBACK(cb.field(ap.view_string()));
			case end_of_row:
				SAXY_RUN_CALLBACK(cb.end_row());
				return true;
			case in_quoted_field:
				require_abort(cb.error(error_code::unclosed_quote));
				return false;
			case require_line_feed:
				require_abort(cb.error(error_code::text_after_closing_quotes));
				return false;
			case error:
				return false;
			default:
				return true;
		}
	}

	template <typename Appender, typename Callback, typename ForwardIt, typename EndIt>
	static bool parse_impl(Appender& ap, Callback& cb, state& s, ForwardIt it, EndIt end, ForwardIt* out = 0) {
		typedef detail::scope_clear<Appender> scope_clear;

		state m_state = s;
		detail::scope_assign<ForwardIt> assign_guard(it, out);
		detail::scope_assign<state> assign_guard2(m_state, &s);

		switch(m_state) {
			SAXY_STATE_JUMP_TABLE(begin);
			SAXY_STATE_JUMP_TABLE(start_of_row);
			SAXY_STATE_JUMP_TABLE(first_field_of_record);
			SAXY_STATE_JUMP_TABLE(fail_on_line_feed);
			SAXY_STATE_JUMP_TABLE(start_of_field);
			SAXY_STATE_JUMP_TABLE(in_quoted_field);
			SAXY_STATE_JUMP_TABLE(in_unquoted_field);
			SAXY_STATE_JUMP_TABLE(in_quote);
			SAXY_STATE_JUMP_TABLE(in_new_line);
			SAXY_STATE_JUMP_TABLE(require_line_feed);
			SAXY_STATE_JUMP_TABLE(end_of_field);
			SAXY_STATE_JUMP_TABLE(end_of_last_field);
			SAXY_STATE_JUMP_TABLE(end_of_row);
			SAXY_STATE_JUMP_TABLE(error);

			default:
				UNREACHABLE;
		}

		begin: {
			if(it != end) {
				SAXY_CHANGE_STATE_AFTER(first_field_of_record, SAXY_RUN_CALLBACK(cb.start_row()));
			} else {
				return true;
			}
		}

		start_of_row: {
			if(it != end) {
				SAXY_CHANGE_STATE_AFTER(first_field_of_record, SAXY_RUN_CALLBACK(cb.start_row()));
			} else {
				return true;
			}
		}

		first_field_of_record: {
			if(it == end) {
				return true;
			}

			ap.start(&*it);

			const char ch = *it;
			switch(ch) {
				case ',':
					++it;
					SAXY_CHANGE_STATE(end_of_field);
				case '"':
					++it;
					ap.start(&*it);
					SAXY_CHANGE_STATE(in_quoted_field);
				case '\r':
					++it;
					SAXY_CHANGE_STATE(fail_on_line_feed);
			}

			ap.append_same(ch);
			++it;
			SAXY_CHANGE_STATE(in_unquoted_field);
		}

		fail_on_line_feed: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			if(ch == '\n') {
				++it;
				SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::no_fields_in_record)));
			} else if(ch == '\r') {
				ap.append('\r');
				++it;
				SAXY_CHANGE_STATE(in_new_line);
			} else {
				const char temp[2] = {'\r', ch };
				ap.append(temp, temp + 2);
				++it;
				SAXY_CHANGE_STATE(in_unquoted_field);
			}
		}

		start_of_field: {
			if(it == end) {
				return true;
			}

			ap.start(&*it);

			const char ch = *it;
			if(ch == ',') {
				++it;
				SAXY_CHANGE_STATE(end_of_field);
			} else if(ch == '"') {
				++it;
				ap.start(&*it);
				SAXY_CHANGE_STATE(in_quoted_field);
			} else if(ch != '\r') {
				ap.append_same(ch);
				++it;
				SAXY_CHANGE_STATE(in_unquoted_field);
			} else {
				++it;
				SAXY_CHANGE_STATE(in_new_line);
			}
		}

		in_unquoted_field: {
			it = no_quote_simd(ap, it, end);

			while(it != end) {
				const char ch = *it;
				if(ch > ',') {
					ap.append_same(ch);
					++it;
				} else {
					if(ch == ',') {
						++it;
						SAXY_CHANGE_STATE(end_of_field);
					} else if(ch == '"') {
						++it;
						SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::misplaced_double_quotes)));
					} else if(ch == '\r') {
						++it;
						SAXY_CHANGE_STATE(in_new_line);
					} else {
						ap.append_same(ch);
						++it;
					}
				}
			}

			return true;
		}

		in_quoted_field: {
			it = in_quote_simd(ap, it, end);

			while(it != end) {
				const char ch = *it;
				if(ch != '"') {
					ap.append(ch);
					++it;
				} else {
					++it;
					SAXY_CHANGE_STATE(in_quote);
				}

			}

			return true;
		}

		in_quote: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			switch(ch) {
				case '"':
					ap.append(ch);
					++it;
					SAXY_CHANGE_STATE(in_quoted_field);
				case ',':
					++it;
					SAXY_CHANGE_STATE(end_of_field);
				case '\r':
					++it;
					SAXY_CHANGE_STATE(require_line_feed);
			}

			++it;
			SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::text_after_closing_quotes)));
		}

		in_new_line: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			if(ch == '\n') {
				++it;
				SAXY_CHANGE_STATE(end_of_last_field);
			} else if(ch == '\r') {
				ap.append('\r');
				++it;
				SAXY_RESTART_STATE(in_new_line);
			} else {
				const char temp[2] = {'\r', ch };
				ap.append(temp, temp + 2);
				++it;
				SAXY_CHANGE_STATE(in_unquoted_field);
			}
		}

		require_line_feed: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			if(ch == '\n') {
				++it;
				SAXY_CHANGE_STATE(end_of_last_field);
			} else {
				++it;
				SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::unfinished_crlf)));
			}
		}

		end_of_field: {
			scope_clear s(ap);
			SAXY_CHANGE_STATE_AFTER(start_of_field,
				SAXY_RUN_CALLBACK(cb.field(ap.view_string()));
			);
		}

		end_of_last_field: {
			scope_clear s(ap);
			SAXY_CHANGE_STATE_AFTER(end_of_row,
				SAXY_RUN_CALLBACK(cb.field(ap.view_string()));
			);
		}

		end_of_row: {
			SAXY_CHANGE_STATE_AFTER(start_of_row, SAXY_RUN_CALLBACK(cb.end_row()));
		}

		error: {
			ap.clear();
			return false;
		}
	}

	template <typename Appender, typename Iterator, typename EndIt>
	__forceinline static Iterator no_quote_simd(Appender& ap, Iterator it, EndIt end) {
		return no_quote_simd(typename detail::use_simd<Iterator, EndIt>::type(), ap, it, end);
	}

	template <typename Appender, typename Iterator, typename EndIt>
	__forceinline static Iterator no_quote_simd(detail::no_simd, Appender&, Iterator it, EndIt) {
		return it;
	}

	template <typename Appender, typename Iterator, typename EndIt>
	__forceinline static Iterator no_quote_simd(detail::simd, Appender& ap, Iterator it, EndIt end) {
		while(end - it >= 16) {
			__m128i const comma = _mm_set1_epi8(',' + 1);
			__m128i const csv = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&*it));
			int const special_chars = _mm_movemask_epi8(_mm_cmplt_epi8(csv, comma));
			int const first_special_char = detail::count_leading_zeros(special_chars);
			ap.append_same(it, it + first_special_char);
			it += first_special_char;
			if(first_special_char != 16) {
				break;
			}
		}

		return it;
	}

	template <typename Appender, typename Iterator, typename EndIt>
	__forceinline static Iterator in_quote_simd(Appender& ap, Iterator it, EndIt end) {
		return in_quote_simd(typename detail::use_simd<Iterator, EndIt>::type(), ap, it, end);
	}

	template <typename Appender, typename Iterator, typename EndIt>
	__forceinline static Iterator in_quote_simd(detail::no_simd, Appender&, Iterator it, EndIt) {
		return it;
	}

	template <typename Appender, typename Iterator, typename EndIt>
	__forceinline static Iterator in_quote_simd(detail::simd, Appender& ap, Iterator it, EndIt end) {
		while(end - it >= 16) {
			__m128i const comma = _mm_set1_epi8(',' - 1);
			__m128i const csv = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&*it));
			unsigned const special_chars = _mm_movemask_epi8(_mm_cmplt_epi8(csv, comma));
			int const first_special_char = detail::count_leading_zeros(special_chars);
			ap.append(it, it + first_special_char); // TODO, special case when we haven't have quotes
			it += first_special_char;
			if(first_special_char != 16) {
				break;
			}
		}

		return it;
	}

public:

	//=========================================================================
	// generator
	//=========================================================================
	class generator {
		std::size_t m_columns;
		std::size_t m_current_column;
	public:
		explicit generator(std::size_t columns)
		: m_columns(columns)
		, m_current_column(0u) {
		}

		template <typename OutputIt>
		OutputIt add_field(OutputIt out, std::string const& str) {
			assert(m_current_column < m_columns);

			std::string::const_iterator it = str.cbegin();
			std::string::const_iterator end = str.cend();
	#if 0
			bool needs_quote = false;
			for(; it != end; ++it) {
				char const ch = *it;
				if(ch == ',' || ch == '"') {
					needs_quote = true;
					break;
				}
			}

			if(needs_quote) {
				*out++ = '"';
			}
	#endif

			it = str.cbegin();
			for(; it != end; ++it) {
				*out++ = *it;
			}

	#if 0
			if(needs_quote) {
				*out++ = '"';
			}
	#endif

			if(++m_current_column == m_columns) {
			} else {
				*out++ = ',';
			}

			return out;
		}

		template <typename OutputIt>
		OutputIt finish_row(OutputIt out) {
			for(; m_current_column < m_columns; ++m_current_column) {
				add_field(out, "");
			}

			*out++ = '\r';
			*out++ = '\n';

			m_current_column = 0;
			return out;
		}
	};
};

char const* csv::name = "CSV";

//-----------------------------------------------------------------------------
// value
//-----------------------------------------------------------------------------
template <typename StringView>
csv::value<StringView>::value(csv::error_code error)
: m_type(csv::error_event)
, m_text()
, m_error(error) {
}

template <typename StringView>
csv::value<StringView>::value(csv::event_code type, StringView str)
: m_type(type)
, m_text(str)
, m_error(csv::none) {
}

template <typename StringView>
csv::event_code csv::value<StringView>::type() const {
	return m_type;
}

template <typename StringView>
StringView csv::value<StringView>::text() const {
	assert(m_type != csv::error_event);
	return m_text;
}

template <typename StringView>
csv::error_code csv::value<StringView>::error() const {
	assert(m_type == csv::error_event);
	return m_error;
}

//-----------------------------------------------------------------------------
// in_place_parser
//-----------------------------------------------------------------------------
csv::in_place_parser::in_place_parser()
: m_appender(0)
, m_end(0)
, m_state(begin)
, m_pos(0) {
}

csv::in_place_parser::in_place_parser(char* start, std::size_t length)
: m_appender(start)
, m_end(start + length)
, m_state(begin)
, m_pos(start) {
}

char const* csv::in_place_parser::position() const {
	return m_pos;
}

template <typename Callback>
bool csv::in_place_parser::parse(Callback& cb, std::size_t max_parse) {
	std::size_t const length = m_end - m_pos;
	bool const result = m_end ? parse_impl(m_appender, cb, m_state, m_pos, m_pos + std::min(max_parse, length), &m_pos)
	                          : parse_impl(m_appender, cb, m_state, m_pos, detail::cstr_end_iterator(), &m_pos);
	return result;
}

//-----------------------------------------------------------------------------
// parser
//-----------------------------------------------------------------------------
template <template <typename> class Allocator>
csv::parser<Allocator>::parser()
: m_state(begin) {
}

template <template <typename> class Allocator>
csv::parser<Allocator>::parser(std::size_t initial_capacity)
: m_state(begin) {
	m_field.reserve(initial_capacity);
}

template <template <typename> class Allocator>
csv::parser<Allocator>::parser(std::size_t initial_capacity, const Allocator<char>& alloc)
: m_field(alloc)
, m_state(begin) {
	m_field.reserve(initial_capacity);
}

template <template <typename> class Allocator>
std::size_t csv::parser<Allocator>::hash() const {
	std::size_t h = m_state;
	h <<= 8;
	typename std::vector<char, Allocator<char> >::const_iterator it = m_field.begin();
	typename std::vector<char, Allocator<char> >::const_iterator end = m_field.end();
	for (; it != end; ++it) {
		h ^= *it;
		h <<= 3;
	}

	return h;
}

template <template <typename> class Allocator>
template <typename Callback>
bool csv::parser<Allocator>::finish(Callback& cb) {
	detail::append_to_vector<std::vector<char, Allocator<char> > > x(m_field);
	return finish_impl(x, cb, m_state);
}

template <template <typename> class Allocator>
template <typename Callback>
bool csv::parser<Allocator>::parse(Callback& cb, char const* str, char const** out) {
	detail::append_to_vector<std::vector<char, Allocator<char> > > x(m_field);

	detail::cstr_end_iterator end;
	bool const result = parse_impl(x, cb, m_state, str, end, out);
	return result;
}

template <template <typename> class Allocator>
template <typename Callback, typename ForwardIt>
bool csv::parser<Allocator>::parse(Callback& cb, ForwardIt it, ForwardIt end, ForwardIt* out) {
	detail::append_to_vector<std::vector<char, Allocator<char> > > x(m_field);
	return parse_impl(x, cb, m_state, it, end, out);
}

template <template <typename> class Allocator>
template <template <typename> class RAllocator>
bool csv::parser<Allocator>::operator==(parser<RAllocator> const& rhs) {
	return m_state == rhs.m_state &&
	       m_field.size() == rhs.m_field.size() &&
	       !std::memcmp(m_field.data(), rhs.m_field.data(), m_field.size());
}

template <template <typename> class Allocator>
template <template <typename> class RAllocator>
bool csv::parser<Allocator>::operator!=(parser<RAllocator> const& rhs) {
	return !(*this == rhs);
}

}

#ifdef SAXY_CPP11
namespace std {

template <template <typename> class Allocator>
struct hash< ::saxy::csv::parser<Allocator> > {
	std::size_t operator()(::saxy::csv::parser<Allocator> const& parser) const {
		return parser.hash();
	}
};

}
#endif


#endif
