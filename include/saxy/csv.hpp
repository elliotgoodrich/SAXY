/*************************************************************************//**
 * \file   csv.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ****************************************************************************/

#ifndef INCLUDE_GUARD_EFC18FC4_94A7_4E93_93A6_1D798FF911E9
#define INCLUDE_GUARD_EFC18FC4_94A7_4E93_93A6_1D798FF911E9

#include "common.hpp"
#include "string_view.hpp"

#include <cassert>
#include <cstring>
#ifdef SAXY_CPP11
  #include <functional>
#endif
#include <memory>
#include <vector>

namespace saxy {

class csv {
	enum state {
		begin,
		start_of_row,
		first_field_of_record,
		fail_on_line_feed,
		start_of_field,
		in_quoted_field,
		in_unquoted_field,
		in_quote,
		in_new_line,
		require_line_feed,
		end_of_field,
		end_of_last_field,
		end_of_row,
		error,
	};

public:
	enum error_code {
		none,
		misplaced_double_quotes,
		text_after_closing_quotes,
		unfinished_crlf,
		unclosed_quote,
		no_fields_in_record,
	};

	static char const* name;

	class in_place_parser {
		detail::in_place m_appender;
		char* m_end;
		state m_state;
		char* m_pos;

	public:
		in_place_parser(char* start, std::size_t length);

		char* position();

		template <typename Callback>
		bool parse(Callback& cb, std::size_t max_parse = -1);
	};

	template <template <typename> class Allocator = std::allocator>
	class parser {
		std::vector<char, Allocator<char> > m_field;
		state m_state;

		template <template <typename> class OtherAlloc>
		friend class parser;

	public:
		/** Create a CSV parser that confirms to RFC 4180
		 */
		parser();

		explicit parser(std::size_t initial_capacity);

		parser(std::size_t initial_capacity, const Allocator<char>& alloc);

		std::size_t hash() const;

		template <typename Callback>
		bool finish(Callback& cb);

		template <typename Callback>
		bool parse(Callback& cb, char const* str, char const** out = 0);

		template <typename Callback, typename ForwardIt>
		bool parse(Callback& cb, ForwardIt it, ForwardIt end, ForwardIt* out = 0);

		template <template <typename> class RAllocator>
		bool operator==(parser<RAllocator> const& rhs);

		template <template <typename> class RAllocator>
		bool operator!=(parser<RAllocator> const& rhs);
	};

	template <typename Callback>
	static bool parse(Callback& cb, char* start, std::size_t length, char** out = 0) {
		state s = begin;
		detail::in_place ap(start);
		return parse_impl(ap, cb, s, start, start + length, out)
		    && finish_impl(ap, cb, s);
	}

	template <typename Callback>
	static bool parse(Callback& cb, char* start, char** out = 0) {
		state s = begin;
		detail::in_place ap(start);
		return parse_impl(ap, cb, s, start, detail::cstr_end_iterator(), out)
		    && finish_impl(ap, cb, s);
	}

private:
	template <typename Appender, typename Callback>
	static bool finish_impl(Appender& ap, Callback& cb, state& m_state) {
		switch(m_state) {
			case begin:
				require_abort(cb.error(error_code::no_fields_in_record));
				return false;
			case fail_on_line_feed:
			case in_new_line:
				ap.append_same('\r');
			case start_of_field:
			case in_unquoted_field:
			case in_quote:
				m_state = end_of_row; // untested line
				SAXY_RUN_CALLBACK(cb.field(ap.view_string()));
			case end_of_row:
				SAXY_RUN_CALLBACK(cb.end_row());
				return true;
			case in_quoted_field:
				require_abort(cb.error(error_code::unclosed_quote));
				return false;
			case require_line_feed:
				require_abort(cb.error(error_code::text_after_closing_quotes));
				return false;
			case error:
				return false;
			default:
				return true;
		}
	}

	template <typename Appender, typename Callback, typename ForwardIt, typename EndIt>
	static bool parse_impl(Appender& ap, Callback& cb, state& s, ForwardIt it, EndIt end, ForwardIt* out = 0) {
		typedef detail::scope_clear<Appender> scope_clear;

		state m_state = s;
		detail::scope_assign<ForwardIt> assign_guard(it, out);
		detail::scope_assign<state> assign_guard2(m_state, &s);

		switch(m_state) {
			SAXY_STATE_JUMP_TABLE(begin);
			SAXY_STATE_JUMP_TABLE(start_of_row);
			SAXY_STATE_JUMP_TABLE(first_field_of_record);
			SAXY_STATE_JUMP_TABLE(fail_on_line_feed);
			SAXY_STATE_JUMP_TABLE(start_of_field);
			SAXY_STATE_JUMP_TABLE(in_quoted_field);
			SAXY_STATE_JUMP_TABLE(in_unquoted_field);
			SAXY_STATE_JUMP_TABLE(in_quote);
			SAXY_STATE_JUMP_TABLE(in_new_line);
			SAXY_STATE_JUMP_TABLE(require_line_feed);
			SAXY_STATE_JUMP_TABLE(end_of_field);
			SAXY_STATE_JUMP_TABLE(end_of_last_field);
			SAXY_STATE_JUMP_TABLE(end_of_row);
			SAXY_STATE_JUMP_TABLE(error);

			default:
				UNREACHABLE;
		}

		begin: {
			if(it != end) {
				SAXY_CHANGE_STATE_AFTER(first_field_of_record, SAXY_RUN_CALLBACK(cb.start_row()));
			} else {
				return true;
			}
		}

		start_of_row: {
			if(it != end) {
				SAXY_CHANGE_STATE_AFTER(first_field_of_record, SAXY_RUN_CALLBACK(cb.start_row()));
			} else {
				return true;
			}
		}

		first_field_of_record: {
			if(it == end) {
				return true;
			}

			ap.start(&*it);

			const char ch = *it;
			switch(ch) {
				case ',':
					++it;
					SAXY_CHANGE_STATE(end_of_field);
				case '"':
					++it;
					ap.start(&*it);
					SAXY_CHANGE_STATE(in_quoted_field);
				case '\r':
					++it;
					SAXY_CHANGE_STATE(fail_on_line_feed);
			}

			ap.all_same(ch);
			++it;
			SAXY_CHANGE_STATE(in_unquoted_field);
		}

		fail_on_line_feed: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			if(ch == '\n') {
				++it;
				SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::no_fields_in_record)));
			} else if(ch == '\r') {
				ap.all_same('\r');
				++it;
				SAXY_CHANGE_STATE(in_new_line);
			} else {
				const char temp[2] = {'\r', ch };
				ap.append_same(temp, temp + 2);
				++it;
				SAXY_CHANGE_STATE(in_unquoted_field);
			}
		}

		start_of_field: {
			if(it == end) {
				return true;
			}

			ap.start(&*it);

			const char ch = *it;
			if(ch == ',') {
				++it;
				SAXY_CHANGE_STATE(end_of_field);
			} else if(ch == '"') {
				++it;
				ap.start(&*it);
				SAXY_CHANGE_STATE(in_quoted_field);
			} else if(ch != '\r') {
				ap.all_same(ch);
				++it;
				SAXY_CHANGE_STATE(in_unquoted_field);
			} else {
				++it;
				SAXY_CHANGE_STATE(in_new_line);
			}
		}

		in_unquoted_field: {
			while(it != end) {
				const char ch = *it;
				if(ch > ',') {
					ap.all_same(ch);
					++it;
				} else {
					if(ch == ',') {
						++it;
						SAXY_CHANGE_STATE(end_of_field);
					} else if(ch == '"') {
						++it;
						SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::misplaced_double_quotes)));
					} else if(ch == '\r') {
						++it;
						SAXY_CHANGE_STATE(in_new_line);
					} else {
						ap.all_same(ch);
						++it;
					}
				}
			}

			return true;
		}

		in_quoted_field: {
			while(it != end) {
				const char ch = *it;
				if(ch != '"') {
					ap.append_same(ch);
					++it;
				} else {
					++it;
					SAXY_CHANGE_STATE(in_quote);
				}

			}

			return true;
		}

		in_quote: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			switch(ch) {
				case '"':
					ap.append_same(ch);
					++it;
					SAXY_CHANGE_STATE(in_quoted_field);
				case ',':
					++it;
					SAXY_CHANGE_STATE(end_of_field);
				case '\r':
					++it;
					SAXY_CHANGE_STATE(require_line_feed);
			}

			++it;
			SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::text_after_closing_quotes)));
		}

		in_new_line: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			if(ch == '\n') {
				++it;
				SAXY_CHANGE_STATE(end_of_last_field);
			} else if(ch == '\r') {
				ap.all_same('\r');
				++it;
				SAXY_RESTART_STATE(in_new_line);
			} else {
				const char temp[2] = {'\r', ch };
				ap.append_same(temp, temp + 2);
				++it;
				SAXY_CHANGE_STATE(in_unquoted_field);
			}
		}

		require_line_feed: {
			if(it == end) {
				return true;
			}

			const char ch = *it;
			if(ch == '\n') {
				++it;
				SAXY_CHANGE_STATE(end_of_last_field);
			} else {
				++it;
				SAXY_CHANGE_STATE_AFTER(error, require_abort(cb.error(error_code::unfinished_crlf)));
			}
		}

		end_of_field: {
			scope_clear s(ap);
			SAXY_CHANGE_STATE_AFTER(start_of_field,
				SAXY_RUN_CALLBACK(cb.field(ap.view_string()));
			);
		}

		end_of_last_field: {
			scope_clear s(ap);
			SAXY_CHANGE_STATE_AFTER(end_of_row,
				SAXY_RUN_CALLBACK(cb.field(ap.view_string()));
			);
		}

		end_of_row: {
			SAXY_CHANGE_STATE_AFTER(start_of_row, SAXY_RUN_CALLBACK(cb.end_row()));
		}

		error: {
			ap.clear();
			return false;
		}
	}

public:

	class generator {
		std::size_t m_columns;
		std::size_t m_current_column;
	public:
		explicit generator(std::size_t columns)
		: m_columns(columns)
		, m_current_column(0u) {
		}

		template <typename OutputIt>
		OutputIt add_field(OutputIt out, std::string const& str) {
			assert(m_current_column < m_columns);

			std::string::const_iterator it = str.cbegin();
			std::string::const_iterator end = str.cend();
	#if 0
			bool needs_quote = false;
			for(; it != end; ++it) {
				char const ch = *it;
				if(ch == ',' || ch == '"') {
					needs_quote = true;
					break;
				}
			}

			if(needs_quote) {
				*out++ = '"';
			}
	#endif

			it = str.cbegin();
			for(; it != end; ++it) {
				*out++ = *it;
			}

	#if 0
			if(needs_quote) {
				*out++ = '"';
			}
	#endif

			if(++m_current_column == m_columns) {
			} else {
				*out++ = ',';
			}

			return out;
		}

		template <typename OutputIt>
		OutputIt finish_row(OutputIt out) {
			for(; m_current_column < m_columns; ++m_current_column) {
				add_field(out, "");
			}

			*out++ = '\r';
			*out++ = '\n';

			m_current_column = 0;
			return out;
		}
	};
};

char const* csv::name = "CSV";

csv::in_place_parser::in_place_parser(char* start, std::size_t length)
: m_appender(start)
, m_end(start + length)
, m_state(begin)
, m_pos(start) {
}

char* csv::in_place_parser::position() {
	return m_appender.current_pos();
}

template <typename Callback>
bool csv::in_place_parser::parse(Callback& cb, std::size_t max_parse) {
	std::size_t const length = m_end - m_pos;
	bool const result = m_end ? parse_impl(m_appender, cb, m_state, m_pos, m_pos + std::min(max_parse, length), &m_pos)
	                          : parse_impl(m_appender, cb, m_state, m_pos, detail::cstr_end_iterator(), &m_pos);
	return result;
}

template <template <typename> class Allocator>
csv::parser<Allocator>::parser()
: m_state(begin) {
}

template <template <typename> class Allocator>
csv::parser<Allocator>::parser(std::size_t initial_capacity)
: m_state(begin) {
	m_field.reserve(initial_capacity);
}

template <template <typename> class Allocator>
csv::parser<Allocator>::parser(std::size_t initial_capacity, const Allocator<char>& alloc)
: m_field(alloc)
, m_state(begin) {
	m_field.reserve(initial_capacity);
}

template <template <typename> class Allocator>
std::size_t csv::parser<Allocator>::hash() const {
	std::size_t h = m_state;
	h <<= 8;
	typename std::vector<char, Allocator<char> >::const_iterator it = m_field.begin();
	typename std::vector<char, Allocator<char> >::const_iterator end = m_field.end();
	for (; it != end; ++it) {
		h ^= *it;
		h <<= 3;
	}

	return h;
}

template <template <typename> class Allocator>
template <typename Callback>
bool csv::parser<Allocator>::finish(Callback& cb) {
	detail::append_to_vector<std::vector<char, Allocator<char> > > x(m_field);
	return finish_impl(x, cb, m_state);
}

template <template <typename> class Allocator>
template <typename Callback>
bool csv::parser<Allocator>::parse(Callback& cb, char const* str, char const** out) {
	detail::append_to_vector<std::vector<char, Allocator<char> > > x(m_field);

	detail::cstr_end_iterator end;
	bool const result = parse_impl(x, cb, m_state, str, end, out);
	return result;
}

template <template <typename> class Allocator>
template <typename Callback, typename ForwardIt>
bool csv::parser<Allocator>::parse(Callback& cb, ForwardIt it, ForwardIt end, ForwardIt* out) {
	detail::append_to_vector<std::vector<char, Allocator<char> > > x(m_field);
	return parse_impl(x, cb, m_state, it, end, out);
}

template <template <typename> class Allocator>
template <template <typename> class RAllocator>
bool csv::parser<Allocator>::operator==(parser<RAllocator> const& rhs) {
	return m_state == rhs.m_state &&
	       m_field.size() == rhs.m_field.size() &&
	       !std::memcmp(m_field.data(), rhs.m_field.data(), m_field.size());
}

template <template <typename> class Allocator>
template <template <typename> class RAllocator>
bool csv::parser<Allocator>::operator!=(parser<RAllocator> const& rhs) {
	return !(*this == rhs);
}

}

#ifdef SAXY_CPP11
namespace std {

template <template <typename> class Allocator>
struct hash< ::saxy::csv::parser<Allocator> > {
	std::size_t operator()(::saxy::csv::parser<Allocator> const& parser) const {
		return parser.hash();
	}
};

}
#endif


#endif
